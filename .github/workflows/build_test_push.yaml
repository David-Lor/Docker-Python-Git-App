name: Build, Test & Push
on:
  workflow_dispatch:
    inputs:
      purgeArtifacts:
        description: "Purge artifacts? (yes/no)"
        required: true
        default: "no"
  push:
    branches:
      - '**'  # all branches
  schedule:
    - cron: '22 2 * * *'  # everyday at 02:22h

jobs:

  mainFlags:
    # Generate main flags for conditioning further jobs and steps
    name: "Main flags"
    runs-on: ubuntu-latest
    outputs:
      flagScheduled: ${{ env.flagScheduled }}
      flagFilesChanged: ${{ env.flagFilesChanged }}
      flagTestBuild: ${{ env.flagTestBuild }}

    steps:
      # Setup
      - name: Checkout
        uses: actions/checkout@master
        with:
          fetch-depth: 0

      # Perform validations
      - name: Verify if any of the image-involved files changed
        id: changed-files
        uses: tj-actions/changed-files@v11.5
        with:
          files: |
            .dockerignore
            Dockerfile
            images.json
            tools/**
            scripts/**
            .github/workflows/**
          # TODO Remove workflows from changed-files detection list

      # Set flags
      - name: Set flag FilesChanged
        if: ${{ steps.changed-files.outputs.any_changed == 'true' }}
        run: echo "flagFilesChanged=true" >> $GITHUB_ENV
      - name: Set flag Scheduled
        if: ${{ github.event_name == 'schedule' }}
        run: echo "flagScheduled=true" >> $GITHUB_ENV
      - name: Set flag TestBuild
        if: ${{ env.flagFilesChanged == 'true' || env.flagScheduled == 'true' }}
        run: echo "flagTestBuild=true" >> $GITHUB_ENV


  purgeArtifacts:
    # Purge all artifacts from previous builds
    # (conditional in step instead of job, because the job must run before other jobs)
    name: Purge artifacts
    runs-on: ubuntu-latest
    steps:
      - name: Purge artifacts
        if: ${{ github.event.inputs.purgeArtifacts == 'yes' }}
        uses: kolpav/purge-artifacts-action@04c636a505f26ebc82f8d070b202fb87ff572b10
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          expire-in: 0


  testBuild:
    # Run "build" tests
    name: Test (build)
    runs-on: ubuntu-latest
    if: ${{ needs.mainFlags.outputs.flagTestBuild == 'true' }}
    needs:
      - mainFlags

    steps:
      # Setup
      - name: Checkout
        uses: actions/checkout@master
        with:
          fetch-depth: 1
      - name: Setup Python
        uses: actions/setup-python@master
        with:
          python-version: "3.8"
          architecture: "x64"
      - name: Install test requirements
        run: make test-install-requirements

      # Test
      - name: Test "build"
        run: make test-build


  imagesMatrix:
    # Parse and set the images & archs matrix to be used by following jobs
    name: Parse & Set images matrix
    runs-on: ubuntu-latest
    if: ${{ needs.mainFlags.outputs.flagTestBuild == 'true' }}
    needs:
      - mainFlags
    outputs:
      images: ${{ steps.set_matrix.outputs.images }}
      archs: ${{ steps.set_matrix.outputs.archs }}
    env:
      # for set_matrix script
      IMAGES_FILE: images.json
      OUTPUT_IMAGES_KEY: images
      OUTPUT_ARCHS_KEY: archs

    steps:
      # Setup
      - name: Checkout
        uses: actions/checkout@master
        with:
          fetch-depth: 1
      - name: Setup Python
        uses: actions/setup-python@v1
        with:
          python-version: 3.7
          architecture: x64

      # Export matrix variables
      - name: Load & Set matrix variables
        id: set_matrix
        run: python .github/workflows/scripts/build_test_push/set_matrix.py


  baseImagesChanged:
    # Determine which base images changed, since last time the workflow ran, by comparing the base image digest
    # from the Registry against the last cached in workflow artifacts.
    # The results are saved on another kind of artifacts, whose existence means that the image changed.
    name: "[${{ matrix.image.fromImage }} (${{ matrix.arch }})] Detect base image changed"
    runs-on: ubuntu-latest
    needs:
      - imagesMatrix
      - purgeArtifacts
    strategy:
      fail-fast: false
      matrix:
        image: ${{ fromJson(needs.imagesMatrix.outputs.images) }}
        arch: ${{ fromJson(needs.imagesMatrix.outputs.archs) }}
    env:
      digestArtifactFile: ./artifacts/digest.txt
      artifactRetentionDays: 7

    steps:
      # Condition
      - name: Determine if job must run
        # This step runs for a matrix combination of image (with its supported archs) & ALL the supported archs from all the images.
        # Some combinations may lead to unsupported image-arch combinations, which are skipped using the env variable from this first step:
        run: |
          JSON_FILE=/tmp/matrix.image.arch.json
          echo '${{ toJson(matrix.image.archs) }}' > $JSON_FILE
          r=$( jq 'contains(["${{ matrix.arch }}"])' $JSON_FILE )
          echo "flagRun=$r" >> $GITHUB_ENV

      # Setup
      - name: Checkout
        uses: actions/checkout@master
        with:
          fetch-depth: 1
      - name: Set image variables
        if: ${{ env.flagRun == 'true' }}
        run: |
          fromImage="${{ matrix.image.fromImage }}"
          echo "fromImage=$fromImage" >> $GITHUB_ENV
          test "$fromImage"
      - name: Set arch variables
        if: ${{ env.flagRun == 'true' }}
        run: |
          arch="${{ matrix.arch }}"
          archOS=$( cut -d '/' -f 1 <<< "$arch" )
          archArch=$( cut -d '/' -f 2- <<< "$arch" )
          echo "arch=$arch" >> $GITHUB_ENV
          echo "archOS=$archOS" >> $GITHUB_ENV
          echo "archArch=$archArch" >> $GITHUB_ENV
          test "$arch"
          test "$archOS"
          test "$archArch"
          test "$arch" == "$archOS/$archArch"
      - name: Set artifact variables
        if: ${{ env.flagRun == 'true' }}
        env:
          BASEIMAGE: ${{ env.fromImage }}
          ARCH: ${{ env.arch }}
        run: |
          bash .github/workflows/scripts/build_test_push/get_image_artifacts_names.sh
      - name: Setup artifact directory & set variable
        if: ${{ env.flagRun == 'true' }}
        run: |
          digestArtifactDir=$( dirname "${{ env.digestArtifactFile }}" )
          echo "digestArtifactDir=$digestArtifactDir" >> $GITHUB_ENV
          test "$digestArtifactDir"
          mkdir -p "$digestArtifactDir"

      # Get last-cached and current digests
      - name: Get latest image digest from Artifact
        if: ${{ env.flagRun == 'true' }}
        continue-on-error: true
        uses: aochmann/actions-download-artifact@5709392f11b5937bd316e52687ad87f7deced5f5
        with:
          name: ${{ env.digestArtifactName }}
          path: ${{ env.digestArtifactDir }}
          latest: true
      - name: Get DockerHub image digest
        if: ${{ env.flagRun == 'true' }}
        id: dockerhub-metadata
        uses: David-Lor/action-dockerhub-get-tag-metadata@0.1.1
        with:
          image: ${{ env.fromImage }}
          os: ${{ env.archOS }}
          architecture: ${{ env.archArch }}
          pageLimit: 10
      - name: Set image digests to environment variables
        if: ${{ env.flagRun == 'true' }}
        run: |
          artifactImageDigest="$( cat '${{ env.digestArtifactFile }}' || echo '' )"
          registryImageDigest="${{ steps.dockerhub-metadata.outputs.digest }}"
          echo "artifactImageDigest=$artifactImageDigest" >> $GITHUB_ENV
          echo "registryImageDigest=$registryImageDigest" >> $GITHUB_ENV
          test "$registryImageDigest"

      # Determine if image was updated on Registry since last time.
      # If yes, save an artifact that acts as a flag for further jobs.
      - name: Determine if image was updated on Registry since last time
        if: ${{ env.flagRun == 'true' }}
        run: |
          if [[ "${{ env.artifactImageDigest }}" == "${{ env.registryImageDigest }}" ]]
          then
            echo "imageDigestChanged=true" >> $GITHUB_ENV
          fi
      - name: Save "image changed" status on Artifact
        if: ${{ env.flagRun == 'true' && env.imageDigestChanged == 'true' }}
        uses: actions/upload-artifact@v2
        with:
          name: ${{ env.imageChangedArtifactName }}
          path: ${{ env.digestArtifactFile }}
          retention-days: 1
          if-no-files-found: error

      # Cache current image digest on artifact
      - name: Save image digest on file
        if: ${{ env.flagRun == 'true' }}
        run: |
          echo "${{ env.registryImageDigest }}" > ${{ env.digestArtifactFile }}
      - name: Save image digest on Artifact
        if: ${{ env.flagRun == 'true' }}
        uses: actions/upload-artifact@v2
        with:
          name: ${{ env.digestArtifactName }}
          path: ${{ env.digestArtifactFile }}
          retention-days: ${{ env.artifactRetentionDays }}
          if-no-files-found: error


  testNoBuild:
    # Run "no-build" tests (pre-building image for linux/amd64, only for images supporting this arch)
    # TODO Only run for non-scheduled events? Problem: in that case, would create many jobs (matrix) what would NEVER run
    name: "[${{ matrix.image.fromImage }} (linux/amd64)] Test (no-build)"
    runs-on: ubuntu-latest
    if: ${{ needs.mainFlags.outputs.flagTestBuild == 'true' }}
    needs:
      - mainFlags
      - testBuild
      - imagesMatrix
    strategy:
      fail-fast: false
      matrix:
        image: ${{ fromJson(needs.imagesMatrix.outputs.images) }}

    steps:
      # Condition
      - name: Determine if job must run
        run: |
          JSON_FILE=/tmp/matrix.image.arch.json
          echo '${{ toJson(matrix.image.archs) }}' > $JSON_FILE
          r=$( jq 'contains(["${{ env.prebuildImageArch }}"])' $JSON_FILE )
          echo "flagRun=$r" >> $GITHUB_ENV

      # Setup
      - name: Checkout
        if: ${{ env.flagRun == 'true' }}
        uses: actions/checkout@master
        with:
          fetch-depth: 1
      - name: Setup Python
        if: ${{ env.flagRun == 'true' }}
        uses: actions/setup-python@master
        with:
          python-version: "3.8"
          architecture: "x64"
      - name: Install test requirements
        if: ${{ env.flagRun == 'true' }}
        run: make test-install-requirements
      - name: Set environment variables
        if: ${{ env.flagRun == 'true' }}
        run: |
          echo "fromImage=${{ matrix.image.fromImage }}" >> $GITHUB_ENV
          echo "toImage=python-git-app:${{ matrix.image.toTag }}" >> $GITHUB_ENV

      # Build
      - name: Build
        if: ${{ env.flagRun == 'true' }}
        run: make build FROM_IMAGE=${{ env.fromImage }} TO_IMAGE=${{ env.toImage }}
      - name: Test "no-build" (arch=default)
        if: ${{ env.flagRun == 'true' }}
        run: make test-nobuild FROM_IMAGE=${{ env.toImage }}


  buildPush:
    # Build image, then push to DockerHub if current branch is "master"
    name: "[${{ matrix.image.fromImage }} -> ${{ matrix.image.toTag }} (${{ matrix.arch }})] Build & Push"
    runs-on: ubuntu-latest
    if: ${{ needs.mainFlags.outputs.flagTestBuild == 'true' }}
    needs:
      - mainFlags
      - testBuild
      - testNoBuild
      - imagesMatrix
      - baseImagesChanged
    strategy:
      fail-fast: false
      matrix:
        image: ${{ fromJson(needs.imagesMatrix.outputs.images) }}
        arch: ${{ fromJson(needs.imagesMatrix.outputs.archs) }}

    steps:
      # Main condition
      - name: Determine if job must run (by image-arch)
        run: |
          JSON_FILE=/tmp/matrix.image.arch.json
          echo '${{ toJson(matrix.image.archs) }}' > $JSON_FILE
          r=$( jq 'contains(["${{ matrix.arch }}"])' $JSON_FILE )
          echo "flagRun=$r" >> $GITHUB_ENV

      # baseImage changed condition (on schedule)
      - name: Set artifact variables (on schedule)
        if: ${{ env.flagRun == 'true' && needs.mainFlags.outputs.flagScheduled == 'true' }}
        env:
          BASEIMAGE: ${{ matrix.image.fromImage }}
          ARCH: ${{ matrix.arch }}
        run: |
          bash .github/workflows/scripts/build_test_push/get_image_artifacts_names.sh
      - name: Download base-image-changed artifact flag (on schedule)
        if: ${{ env.flagRun == 'true' && needs.mainFlags.outputs.flagScheduled == 'true' }}
        id: imageChangedArtifactDownload
        uses: actions/download-artifact@v2
        continue-on-error: true
        with:
          name: ${{ env.imageChangedArtifactName }}
          path: /tmp
      - name: Determine if job must run (by base image updated, on schedule)
        if: ${{ env.flagRun == 'true' && needs.mainFlags.outputs.flagScheduled == 'true' }}
        run: |
          if [[ ${{ steps.imageChangedArtifactDownload.outcome != 'success' }} ]]
          then
            echo "flagRun=false" >> $GITHUB_ENV
          fi

      # Conditions for other steps
      - name: Determine if install QEMU
        if: ${{ env.flagRun == 'true' }}
        run: |
          if [[ "${{ matrix.arch }}" != "linux/amd64" ]]
          then
            echo "flagQEMU=true" >> $GITHUB_ENV
          fi
      - name: Determine if must push built image
        if: ${{ env.flagRun == 'true' && github.ref == 'refs/heads/master' }}
        run: |
          echo "flagPush=true >> $GITHUB_ENV"

      # Setup
      - name: Checkout
        if: ${{ env.flagRun == 'true' }}
        uses: actions/checkout@master
        with:
          fetch-depth: 1
      - name: Install QEMU
        if: ${{ env.flagRun == 'true' && env.flagQEMU == 'true' }}
        uses: docker/setup-qemu-action@v1
      - name: Install Docker Buildx
        if: ${{ env.flagRun == 'true' }}
        uses: docker/setup-buildx-action@v1
      - name: Set environment variables
        if: ${{ env.flagRun == 'true' }}
        run: |
          echo "fromImage=${{ matrix.image.fromImage }}" >> $GITHUB_ENV
          echo "toTag=${{ matrix.image.toTag }}" >> $GITHUB_ENV
          echo "arch=${{ matrix.arch }}" >> $GITHUB_ENV
          echo "buildxPush=false" >> $GITHUB_ENV
          if [[ '${{ env.flagPush }}' == 'true' ]]
          then
            echo "buildxPush=true" >> $GITHUB_ENV
          fi

      # Docker login
      - name: Login to DockerHub
        if: ${{ env.flagRun == 'true' && env.buildxPush == 'true' }}
        uses: docker/login-action@v1
        with:
          username: ${{ secrets.DOCKER_USER }}
          password: ${{ secrets.DOCKER_PASS }}

      # Build/Push
      - name: Build & Push for all archs
        if: ${{ env.flagRun == 'true' }}
        run: make buildx FROM_IMAGE=${{ env.fromImage }} TO_TAG=${{ env.toTag }} BUILDX_PUSH=${{ env.buildxPush }} ARCH=${{ env.arch }}
